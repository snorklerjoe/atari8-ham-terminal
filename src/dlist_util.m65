;
; Utils for display list stuff
;

ORIG_NMIEN .byte $FF
ORIG_SDLSTL .byte $FF,$FF

; Display list interrupt
dli:
    rti
    pha
    lda #00
    sta WSYNC
    sta COLBK
    pla
    rti

; Install dl
dl_install:
    ldx NMIEN
    stx ORIG_NMIEN
    lda #00
    sta NMIEN ; Disable vbi and nmi etc etc


    ; Save current display list
    mov16 SDLSTL,ORIG_SDLSTL
    ; Load display list
    staddr dlist,SDLSTL

    ; Install dli
    staddr dli,VDSLST

    txa
    ora #$C0  ; enable vbi and nmi
    sta NMIEN

    ; Set cursor position
    staddr scrollablebuf_lastline,CRSADR
    staddr scrollablebuf_lastline,LINADR
;    staddr numrows,ROWCRS
    lda #00
;    sta COLCRS

    rts

; Restore original dl
dl_restore:
    lda ORIG_NMIEN
    sta NMIEN
    mov16 ORIG_SDLSTL,SDLSTL
    rts

; Sets the location of the bottom line of the screen on the screenbuffer
; Also updates each other visible line accordingly
; Uses A,X, ARITHBUF
.local
dl_setzero:
    ; Load offset
    ldx #(dlist_coarse_address0 - dlist_coarse_address_top)
    ; ARITHBUF stores line address for current line in this routine
    mov16 LINADR, ARITHBUF

?update
    ; Update value
    lda ARITHBUF
    sta dlist_coarse_address_top, X
    lda ARITHBUF+1
    sta dlist_coarse_address_top+1, X    ldy COLCRS


    ; Update arithbuf to point to next line
    sbc168 ARITHBUF, numcolumns
    ; LSB stored in A after sbc168
    cmp #<scrollablebuf_start
    bne ?nextline
    lda ARITHBUF+1
    cmp #>scrollablebuf_start
    bne ?nextline

    ; Well then, we need to wrap to the end of the buffer!
    staddr scrollablebuf_lastline, ARITHBUF

?nextline
    ; Move up a row and loop if necessary
    dex
    dex
    dex
    cpx #$FD
    bne ?update

    rts

; Scrolls the display up by one
.local
dl_scroll_one:
    adc168 LINADR, numcolumns

    cmp #<scrollablebuf_lastline
    bne ?nowrap
    lda LINADR+1
    cmp #>scrollablebuf_lastline
    bne ?nowrap
    ; Well then, we need to wrap to the end of the buffer!
    staddr scrollablebuf_start, LINADR

?nowrap
    mov16 LINADR, CRSADR
    rts

; Scrolls the display up by one and clears a line
.local
dl_newline:
    jsr dl_scroll_one
    lda #00
    sta COLCRS  ; "Carriage return"
    ldy #numcolumns+1
?loop
    dey
    sta (LINADR), Y
    bne ?loop
    rts

; Puts an internal charcode to the buf
.local
putint:
    ldy COLCRS
    sta (LINADR), Y
    iny
    sty COLCRS
    cpy #numcolumns
    bne ?nowrap

    ; Wrap
    jsr dl_newline
    jsr dl_setzero

?nowrap
    inc16 CRSADR
    rts

