; Utilities & Macros

; Macro to take location (addr) and put at (pointer)
; Only uses the A register
.macro staddr ; addr,pointer
    .IF %0<>2
        .ERROR "staddr needs 2 params"
    .ENDIF
    lda #<%1
    sta %2
    lda #>%1
    sta %2+1
.endm

; Macro to copy a 16-bit word from one location to another
.macro mov16 ; to,from
    .IF %0<>2
        .ERROR "mov16 needs 2 16 bit params"
    .ENDIF
    lda %1
    sta %2
    lda %1+1
    sta %2+1
.endm

; Macro to multiply A by a constant value -- Give # shifts, # adds
.macro constmult8 ; k
    .if %0<>2
        .error "mult8 needs #shifts, #adds"
    .endif
    sta MULTREG
    .rept %1
        asl
    .endr
    .rept %2
        adc MULTREG
    .endr
.endm

; macro to increment a 16-bit value in memory (LSB, MSB)
.macro inc16 ; addr
    .if %0<>1
        .error "inc16 needs addr"
    .endif
    clc
    inc %1
    bcc @incdone
    inc %1+1
@incdone
    nop
.endm

; macro to decrement a 16-bit value in memory (LSB, MSB)
; Uses A
.macro dec16 ; addr
    .if %0<>1
        .error "dec16 needs addr"
    .endif
    lda %1
    bne @sbdecdone  ; Branch past msb decrement if init lsb not zero

    dec %1+1 ; Decrement the MSB

@msbdecdone
    dec %1 ; Decrement LSB no matter what
.endm

; macro to subtract (w/carry) 8-bit val from a 16-bit value in memory (LSB, MSB)
; Uses A; ends with lsb stored in A
.macro sbc168 ; addr,val
    .if %0<>2
        .error "sbc16 needs addr,val"
    .endif
    lda %1
;    cmp #%2
    sec
    sbc #%2
    bcs @msbborrowdone  ; Branch past msb decrement if init lsb not zero

    dec %1+1  ; Decrement the MSB

@msbborrowdone
    ;lda %1 ; subtract from LSB no matter what
    sta %1
.endm

; macro to add (w/carry) 8-bit val to a 16-bit value in memory (LSB, MSB)
; Uses A; ends with lsb stored in A
.macro adc168 ; addr,val
    .if %0<>2
        .error "adc16 needs addr,val"
    .endif
    lda %1
;    cmp #%2
    clc
    adc #%2
    bcc @msbborrowdone  ; Branch past msb decrement if init lsb not zero

    inc %1+1  ; Decrement the MSB

@msbborrowdone
    ;lda %1 ; subtract from LSB no matter what
    sta %1
.endm

; Macro to shift left or right (if negative) n times
.macro aslconst
        .rept %1
            asl A
        .endr
.endm

.macro asrconst
        .rept %1
            and #~11111110 ; turn rotate into shift
            ror A
        .endr
.endm

; BEQ but a jump, like for long range
.local
.macro jmpeq
    bne @nojmp
    jmp %1
@nojmp
.endm

.macro phx
    txa
    pha
.endm
.macro phy
    tya
    pha
.endm
.macro plx
    pla
    tax
.endm
.macro ply
    pla
    tay
.endm

; LDA #%2 if A == #%1
.local
.macro ldaifeq
    cmp #%1
    bne @donelie
    lda #%2
@donelie
.endm
