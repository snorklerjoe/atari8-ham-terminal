;
; Handles drawing the cursor & location thereof
; & also plotting
;


; .local
; ; Calculates CRSADR from position
; POSITION:
;     ; Multiply Y by num cols
;     lda ROWCRS
;     clc
;     constmult8 colshift,colremainder
;     ; Store LSB
;     sta CRSADR

;     ; Multiply MSB
;     lda ROWCRS+1
;     constmult8 colshift,colremainder
;     sta CRSADR+1

;     ; Increment the MSB result if carry set from LSB mult
;     bcc .01
;     inc CRSADR+1
; .01:

;     ; Next, add the 
;     rts


; Puts the cursor in the "zero" position
ZERO:
    staddr cursor_zero,CRSADR
    staddr cursor_zero,LINADR
    mov16 #numrows,ROWCRS
    lda #00
    sta COLCRS
    rts


.local
; Puts the internal char code in A at the cursor location and increments the cursor
; Uses A, Y
PUTINT:
    ldy COLCRS
    sta (LINADR),y
    clc
    inc COLCRS
;     lda COLCRS
;     cmp #numcolumns  ; If we wrap to the next line,
;     bne @01
;     lda #00
;     sta COLCRS
; @01:
    inc16 CRSADR
    rts
;    jmp position  ; Update address for the next time
    ;rts    ; position will return for us :)



; .local
; ; Moves a the next line (after address LINADR) on the screen up by one
; ; Uses A, Y, ARITHBUF
; MOVLN:
;     ; Calculate addr of next line down
;     mov16 LINADR, ARITHBUF
;     adc16 ARITHBUF, numcolumns

;     ; For each char in line
;     ldy #00
; @loop:
;     lda (ARITHBUF), Y
;     sta (LINADR), Y
;     iny

;     ; Loop for each char in line
;     cpy #numcolumns
;     bne @loop
;     rts

; .local
; ; Scrolls each line up one, discarding the last
; SCROLLUP:
;     ; Push current line loc to stack
;     lda LINADR
;     pha
;     lda LINADR+1
;     pha
;     ; For each line in buffer, starting with the top
;     staddr offscr_scrollablebuf, LINADR

;     ldy #numrows

;     ?loop
;     jsr MOVLN
;     adc168 LINADR, numcolumns

;     ; Decrement & loop if not zero
;     dey
;     bne ?loop

;     ; Restore line loc
;     pla
;     sta LINADR+1
;     pla
;     sta LINADR

;     rts
