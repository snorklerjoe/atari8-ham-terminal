;
; Utils for display list stuff
;

ORIG_NMIEN .byte $FF
ORIG_SDLSTL .byte $FF,$FF

; Display list interrupt
dli:
    pha
    lda #$E0
    sta WSYNC
;    sta COLBK
    sta COLPF0+2
    pla
    rti

; Install dl
dl_install:
    ; Get colors right
    lda #$F0
    sta COLOR0+2
    sta COLOR0+4
    lda #$FF
    sta COLOR0+1

    ; everything else:
    ldx NMIEN
    stx ORIG_NMIEN
    lda #00
    sta NMIEN ; Disable vbi and nmi etc etc


    ; Save current display list
    mov16 SDLSTL,ORIG_SDLSTL
    ; Load display list
    staddr dlist,SDLSTL

    ; Install dli
    staddr dli,VDSLST

    txa
    lda #$C0  ; enable vbi and nmi
    sta NMIEN

    ; Set cursor position
    staddr scrollablebuf_lastline,CRSADR
    staddr scrollablebuf_lastline,LINADR
;    staddr numrows,ROWCRS
    lda #00
    sta COLCRS

    rts

; Restore original dl
dl_restore:
    lda ORIG_NMIEN
    sta NMIEN
    mov16 ORIG_SDLSTL,SDLSTL
    rts

; Sets the location of the bottom line of the screen on the screenbuffer
; Also updates each other visible line accordingly
; Uses A,X, ARITHBUF
.local
dl_setzero:
    ; Load offset
    ldx #(dlist_coarse_address0 - dlist_coarse_address_top)
    ; ARITHBUF stores line address for current line in this routine
    mov16 LINADR, ARITHBUF

?update
    ; Update value
    lda ARITHBUF
    sta dlist_coarse_address_top, X
    lda ARITHBUF+1
    sta dlist_coarse_address_top+1, X

    lda arithbuf
    cmp #<scrollablebuf_start
    bne ?moveln
    lda ARITHBUF+1
    cmp #>scrollablebuf_start
    bne ?moveln

    ; Well then, we need to wrap to the end of the buffer!
    staddr scrollablebuf_lastline, ARITHBUF
    jmp ?nextline

?moveln
    ; Update arithbuf to point to next line
    sbc168 ARITHBUF, numcolumns

?nextline
    ; Move up a row and loop if necessary
    dex
    dex
    dex
;    cpx #$FD
    bpl ?update

    rts

; Scrolls the display up by one
.local
dl_scroll_one:
    lda LINADR
    cmp #<scrollablebuf_lastline
    bne ?nowrap
    lda LINADR+1
    cmp #>scrollablebuf_lastline
    bne ?nowrap
    ; Well then, we need to wrap to the beginning of the buffer!
    staddr scrollablebuf_start, LINADR
    jmp ?stcaddr
?nowrap
    adc168 LINADR, numcolumns
?stcaddr
    mov16 LINADR, CRSADR
    rts

; Scrolls the display up by one and clears a line
.local
dl_newline:
    jsr dl_scroll_one
    lda #00
    sta COLCRS  ; "Carriage return"
    ldy #numcolumns
?loop
    dey
    sta (LINADR), Y
    bne ?loop
    rts

; Puts an internal charcode to the buf
.local
putint:
    ldy COLCRS
    sta (LINADR), Y
    iny
    sty COLCRS
    cpy #numcolumns
    bne ?nowrap

    ; Wrap
    jsr dl_newline
    jsr dl_setzero

?nowrap
    lda #$80
    sta (LINADR), Y
;    inc16 CRSADR
    rts

; Puts char from A to screen with wrap
; Uses A,Y
.local
PUTCH:
    ; Convert ATASCII to internal char code
    cmp #32
    blt @01
    sbc #32
    jmp @02
@01: ; Less than ATASCII 32
    adc #64
@02:
    jsr PUTINT
    rts

; Backspace... that's all.
; uses A,Y
.local
backspace:
    ldy colcrs
    beq ?nuthin  ; Already at the start of a line = no backspace.

    dey
    lda #0
    sta (linadr), y
    sty colcrs

?nuthin
    rts
