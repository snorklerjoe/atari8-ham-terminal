;
; Utils for display stuff
;

; Inverse underbar
cursor_int=63


ORIG_NMIEN .byte $FF
ORIG_SDLSTL .byte $FF,$FF

; Display list interrupt
dli:
    pha
    lda #$E0
    sta WSYNC
;    sta COLBK
    sta COLPF0+2
    pla
    rti

.local
; VBlank Interrupt Routine
vbi:
    pha
    tya
    pha

    lda RTCLOK+2
    and #16
    bne ?nah

    ; Blink cursor (alternate)
    lda CRSON
    cmp #00
    bne ?curoff

    jsr cursor_draw
    jmp ?nah

?curoff
    jsr cursor_undraw


?nah
    pla
    tay
    pla
    jmp XITVBV

; Install dl & vbi
dl_vbi_install:
    ; Get colors right
    lda #$F0
    sta COLOR0+2
    sta COLOR0+4
    lda #$FF
    sta COLOR0+1

    ; everything else:
    ldx NMIEN
    stx ORIG_NMIEN
    lda #00
    sta NMIEN ; Disable vbi and nmi etc etc


    ; Save current display list
    mov16 SDLSTL,ORIG_SDLSTL
    ; Load display list
    staddr dlist,SDLSTL

    ; Install dli
    staddr dli,VDSLST

    ; Install vbi
    lda #07
    ldx #>vbi
    ldy #<vbi
    jsr SETVBV

    lda #$C0  ; enable vbi and nmi
    sta NMIEN

    ; Set cursor position
    staddr scrollablebuf_lastline,CRSADR
    staddr scrollablebuf_lastline,LINADR
;    staddr numrows,ROWCRS
    lda #00
    sta COLCRS

    lda #00
    sta crson
    sta undercrs

    rts

; Restore original dl
dl_restore:
    lda ORIG_NMIEN
    sta NMIEN
    mov16 ORIG_SDLSTL,SDLSTL
    rts

; Sets the location of the bottom line of the screen on the screenbuffer
; Also updates each other visible line accordingly
; Uses A,X, ARITHBUF
.local
dl_setzero:
    ; Load offset
    ldx #(dlist_coarse_address0 - dlist_coarse_address_top)
    ; ARITHBUF stores line address for current line in this routine
    mov16 LINADR, ARITHBUF

?update
    ; Update value
    lda ARITHBUF
    sta dlist_coarse_address_top, X
    lda ARITHBUF+1
    sta dlist_coarse_address_top+1, X

    lda arithbuf
    cmp #<scrollablebuf_start
    bne ?moveln
    lda ARITHBUF+1
    cmp #>scrollablebuf_start
    bne ?moveln

    ; Well then, we need to wrap to the end of the buffer!
    staddr scrollablebuf_lastline, ARITHBUF
    jmp ?nextline

?moveln
    ; Update arithbuf to point to next line
    sbc168 ARITHBUF, numcolumns

?nextline
    ; Move up a row and loop if necessary
    dex
    dex
    dex
;    cpx #$FD
    bpl ?update

    rts

; Scrolls the display up by one
.local
dl_scroll_one:
    jsr cursor_undraw
    lda LINADR
    cmp #<scrollablebuf_lastline
    bne ?nowrap
    lda LINADR+1
    cmp #>scrollablebuf_lastline
    bne ?nowrap
    ; Well then, we need to wrap to the beginning of the buffer!
    staddr scrollablebuf_start, LINADR
    jmp ?stcaddr
?nowrap
    adc168 LINADR, numcolumns
?stcaddr
    mov16 LINADR, CRSADR
    rts

; Scrolls the display up by one and clears a line
.local
dl_newline:
    jsr dl_scroll_one
    lda #00
    sta COLCRS  ; "Carriage return"
    ldy #numcolumns
?loop
    dey
    sta (LINADR), Y
    bne ?loop
    rts

; Puts an internal charcode to the buf
.local
putint:
    tax
    jsr cursor_undraw
    txa

    ldy COLCRS
    sta (LINADR), Y
    iny
    sty COLCRS
    cpy #numcolumns
    bne ?nowrap

    ; Wrap
    jsr dl_newline
    jsr dl_setzero

?nowrap
;    inc16 CRSADR
    rts

; Puts char from A to screen with wrap
; Uses A,Y
.local
PUTCH:
    ; Convert ATASCII to internal char code
    cmp #32
    blt @01
    sbc #32
    jmp @02
@01: ; Less than ATASCII 32
    adc #64
@02:
    jsr PUTINT
    rts

; Backspace... that's all.
; uses A,Y
.local
backspace:
    jsr cursor_undraw
    ldy colcrs
    beq ?nuthin  ; Already at the start of a line = no backspace.

    dey
    lda #0
    sta (linadr), y
    sty colcrs

?nuthin
    rts

; Draw cursor
; Uses A, Y
.local
cursor_draw:
    lda crson  ; Cannot draw if already drawn
    cmp #00
    bne ?nodraw

    dec crson
    ldy colcrs
    lda (linadr), y
    sta undercrs
    lda #cursor_int
    sta (linadr), y
?nodraw
    rts

; Undraw cursor
; Uses A, Y
.local
cursor_undraw:
    lda crson
    cmp #00
    beq ?noundraw

    inc crson
    ldy colcrs
    lda undercrs
    sta (linadr), y
?noundraw
    rts
