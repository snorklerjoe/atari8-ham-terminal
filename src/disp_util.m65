;
; Utils for display stuff
;

; underbar
cursor_int=63


ORIG_NMIEN .byte $FF
ORIG_SDLSTL .byte $FF,$FF

; Display list interrupt
dli:
    php
    pha
    lda #$E0
    sta WSYNC
;    sta COLBK
    sta COLPF0+2
    pla
    plp
    rti

.local
; VBlank Interrupt Routine
vbi:  ; TODO: shut off cursor blink completely when necessary
    php
    pha
    txa
    pha
    tya
    pha

    lda RTCLOK+2
    and #~00001111
    bne ?nah

    ; Toggle cursor
    lda CRSON
    cmp #$FF
    beq ?nah
    cmp #01
    bne ?curoff

    jsr cursor_draw
    jmp ?nah

?curoff
    jsr cursor_undraw

?nah
    pla
    tay
    pla
    tax
    pla
    plp
    jmp XITVBV

; Install dl & vbi
dl_vbi_install:
    ; Get colors right
    lda #$F0
    sta COLOR0+2
    sta COLOR0+4
    lda #$FF
    sta COLOR0+1

    ; everything else:
    ldx NMIEN
    stx ORIG_NMIEN
    lda #00
    sta NMIEN ; Disable vbi and nmi etc etc


    ; Save current display list
    mov16 SDLSTL,ORIG_SDLSTL
    ; Load display list
    staddr dlist,SDLSTL

    ; Install dli
    staddr dli,VDSLST

    ; Install vbi
    lda #07
    ldx #>vbi
    ldy #<vbi
    jsr SETVBV

    lda #$C0  ; enable vbi and nmi
    sta NMIEN

    ; Set cursor position
    staddr scrollablebuf_lastline,CRSADR
    staddr scrollablebuf_lastline,LINADR
;    staddr numrows,ROWCRS
    lda #00
    sta COLCRS

    lda #01
    sta crson
    sta undercrs

    rts

; Restore original dl
dl_restore:
    lda ORIG_NMIEN
    sta NMIEN
    mov16 ORIG_SDLSTL,SDLSTL
    rts

; Sets the location of the bottom line of the screen on the screenbuffer
; Also updates each other visible line accordingly
; Uses A,X, ARITHBUF
.local
dl_setzero:
    ; Load offset
    ldx #(dlist_coarse_address0 - dlist_coarse_address_top)
    ; ARITHBUF stores line address for current line in this routine
    mov16 LINADR, ARITHBUF

?update
    ; Update value
    lda ARITHBUF
    sta dlist_coarse_address_top, X
    lda ARITHBUF+1
    sta dlist_coarse_address_top+1, X

    lda arithbuf
    cmp #<scrollablebuf_start
    bne ?moveln
    lda ARITHBUF+1
    cmp #>scrollablebuf_start
    bne ?moveln

    ; Well then, we need to wrap to the end of the buffer!
    staddr scrollablebuf_lastline, ARITHBUF
    jmp ?nextline

?moveln
    ; Update arithbuf to point to next line
    sbc168 ARITHBUF, numcolumns

?nextline
    ; Move up a row and loop if necessary
    dex
    dex
    dex
;    cpx #$FD
    bpl ?update

    rts

; Scrolls the display up by one
.local
dl_scroll_one:
    jsr cursor_undraw
    dec crson ; make sure cursor won't go off (will take multiple vblank cycles)
    
    lda LINADR
    cmp #<scrollablebuf_lastline
    bne ?nowrap
    lda LINADR+1
    cmp #>scrollablebuf_lastline
    bne ?nowrap
    ; Well then, we need to wrap to the beginning of the buffer!
    staddr scrollablebuf_start, LINADR
    jmp ?stcaddr
?nowrap
    adc168 LINADR, numcolumns
?stcaddr
    mov16 LINADR, CRSADR
    rts

; Scrolls the display back by one
.local
dl_scroll_back_one:
    jsr cursor_undraw
    dec crson
    
    lda LINADR
    cmp #<scrollablebuf_start
    bne ?nowrap
    lda LINADR+1
    cmp #>scrollablebuf_start
    bne ?nowrap
    ; Well then, we need to wrap to the beginning of the buffer!
    staddr scrollablebuf_lastline, LINADR
    jmp ?stcaddr
?nowrap
    sbc168 LINADR, numcolumns
?stcaddr
    mov16 LINADR, CRSADR
    rts

; Scrolls the display up by one and clears a line
.local
dl_newline:
    jsr dl_scroll_one
    lda #00
    sta COLCRS  ; "Carriage return"
    ldy #numcolumns
?loop
    dey
    sta (LINADR), Y
    bne ?loop
    rts

; Puts an internal charcode to the buf
; Does not undraw cursor first.
; Uses A,y
.local
putint:
    ldy COLCRS
    sta (LINADR), Y
    iny
    sty COLCRS
    cpy #numcolumns
    bne ?nowrap

    ; Wrap
    jsr dl_newline
    jsr dl_setzero

?nowrap
;    inc16 CRSADR
    rts

; Puts char from A to screen with wrap
; Does not undraw cursor first.
; Uses A,Y
.local
PUTCH:
    ; Convert ATASCII to internal char code
    cmp #$9B
    beq ?10

    cmp #96
    bcs ?09
    cmp #32
    blt ?09
    sbc #32
    jmp ?09
?01: ; Less than ATASCII 32
    adc #64
    jmp ?09

?09:
    jsr PUTINT
    rts
?10: ; Newline
    jsr dl_newline
    jmp dl_setzero

; Backspace... that's all.
; Does not undraw cursor first.
; uses A,Y
.local
backspace:
    ldy colcrs
    beq ?nuthin  ; Already at the start of a line = no backspace.

    dey
    lda #0
    sta (linadr), y
    sty colcrs

?nuthin
    rts

; Draw cursor
; Uses A, Y
.local
cursor_draw:
    sec
    lda crson  ; Cannot draw if already drawn
    cmp #01
    bcc ?02
    bne ?01


    dec crson
    ldy colcrs
    lda (linadr), y
    sta undercrs
    lda #cursor_int
    sta (linadr), y
?01
    rts
?02
    dec crson
    rts

; Undraw cursor
; Uses A, Y
.local
cursor_undraw:
    lda crson
    cmp #00
    bne ?noundraw

    inc crson
    ldy colcrs
    lda undercrs
    sta (linadr), y
?noundraw
    rts

; Enables cursor
.local
encurs:
    lda crson
    clc
    cmp #01
    bcc ?noencurs
    lda #01
    sta crson
?noencurs
    rts

; Disables cursor until encurs
discurs:
    lda #$ff
    sta crson
    rts

.macro setcolor ; reg #, color value
    lda #%2
    sta COLOR0 + %1
.endm

.macro tempsetcolor  ; setcolor but pushes to stack
    lda COLOR0 + %1
    pha
    setcolor %1,%2
.endm

.macro returncolor  ; Return from tempsetcolor
    pla
    sta COLOR0 + %1
.endm
