; Screen i/o

; If using IOCB0, it could break other things that expect that to be E:
KEY_IOCB = $20

KDEV: .byte "K:",$9B


; Inits the screen & kbd and opens IOCB0
KEYINIT:
    ; KEYBOARD
    ; Close if previously opened...
    ldx #KEY_IOCB
    jsr CIO_CLOSE

    ; Open anew...
    staddr KDEV,BUFPTR
    lda #OPNIN
    jsr CIO_OPEN

    ; Turn off Capslock
    lda #00
    sta SHFLOK

    rts

; Closes down the screen
KEYCLOSE:
    ; KEYBOARD
    ldx #KEY_IOCB
    jsr CIO_CLOSE
    rts

; Prints to the screen 
; Call after a `staddr {buf} BUFPTR`
;PRINT:
;    ldx #SCR_IOCB
;    jsr CIO_WRITE
;    rts


_CHRBUF: .byte $00, $9B

; Clears buffer & gets char from kbd into A
GETCH:
    ldx #KEY_IOCB
    lda #$FF
    sta CH
    staddr _CHRBUF,BUFPTR
    lda #01
    jsr CIO_GET
    lda _CHRBUF
    rts


; Gets char from kbd (or buffer) into A
READCH:
    ldx #KEY_IOCB
    staddr _CHRBUF,BUFPTR
    lda #01
    jsr CIO_GET
    lda _CHRBUF
    rts


; Sets carry flag if a character is available to be read, else clears it.
CHRAVAIL:
    clc
    ldx CH
    inx
    rts

; Produces a key click.
; Similar to the OS routine, but rewritten here to be more portable
; Just uses wsync... might mess things up bc it blocks until the click is done.
CLICK:
    ldx #$5f
clickloop:
    stx consol
    stx wsync

    dex
    bpl clickloop
    rts
