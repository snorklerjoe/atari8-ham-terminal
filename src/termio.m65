; Screen i/o

; If using IOCB0, it could break other things that expect that to be E:
KEY_IOCB = $20

KDEV: .byte "K:",$9B


; Inits the screen & kbd and opens IOCB0
TERMINIT:
    ; KEYBOARD
    ; Close if previously opened...
    ldx #KEY_IOCB
    jsr CIO_CLOSE

    ; Open anew...
    staddr KDEV,BUFPTR
    lda #OPNIN
    jsr CIO_OPEN
    rts

; Closes down the screen
TERMCLOSE:
    ; KEYBOARD
    ldx #KEY_IOCB
    jsr CIO_CLOSE
    rts

; Prints to the screen 
; Call after a `staddr {buf} BUFPTR`
;PRINT:
;    ldx #SCR_IOCB
;    jsr CIO_WRITE
;    rts


_CHRBUF: .byte $00, $9B

; Clears buffer & gets char from kbd into A
GETCH:
    ldx #KEY_IOCB
    lda #$FF
    sta CH
    staddr _CHRBUF,BUFPTR
    lda #01
    jsr CIO_GET
    lda _CHRBUF
    rts


; Gets char from kbd (or buffer) into A
READCH:
    ldx #KEY_IOCB
    staddr _CHRBUF,BUFPTR
    lda #01
    jsr CIO_GET
    lda _CHRBUF
    rts


; Sets carry flag if a character is available to be read, else clears it.
CHRAVAIL:
    clc
    ldx CH
    inx
    rts


; Puts char from A to screen
; Uses A,Y
.local
PUTCH:
    ; Convert ATASCII to internal char code
    cmp #32
    blt @01
    sbc #32
    jmp @02
@01: ; Less than ATASCII 32
    adc #64
@02:
    jsr PUTINT
    rts
